[
    {
        "content": "/**\n * # Simple voting contract complete spec\n *\n * To use gambit, run from the tutorials-code root folder the following command:\n * `certoraMutate --prover_conf solutions/lesson4_invariants/simple_voting/Voting_solution.conf --mutation_conf solutions/lesson4_invariants/simple_voting/mutate.json`\n */\nmethods\n{\n    function votesInFavor() external returns (uint256) envfree;\n    function votesAgainst() external returns (uint256) envfree;\n    function totalVotes() external returns (uint256) envfree;\n    function hasVoted(address) external returns (bool) envfree;\n}",
        "type": "methods",
        "notice": "# Simple voting contract complete spec\n\nTo use gambit, run from the tutorials-code root folder the following command:\n`certoraMutate --prover_conf solutions/lesson4_invariants/simple_voting/Voting_solution.conf --mutation_conf solutions/lesson4_invariants/simple_voting/mutate.json`"
    },
    {
        "content": "/// @title Count the number of times `_hasVoted` been written to\nghost mathint numVoted {\n    init_state axiom numVoted == 0;\n}",
        "type": "ghost",
        "id": "numVoted",
        "title": "Count the number of times `_hasVoted` been written to"
    },
    {
        "content": "/// @title For ensuring all changes to `_hasVoted` are legal\nghost bool illegalStore {\n    init_state axiom !illegalStore;\n}",
        "type": "ghost",
        "id": "illegalStore",
        "title": "For ensuring all changes to `_hasVoted` are legal"
    },
    {
        "content": "/// @title Ghost indicating someone has voted\nghost bool someoneVoted;",
        "type": "ghost",
        "id": "someoneVoted",
        "title": "Ghost indicating someone has voted"
    },
    {
        "content": "/// @title No illegal changes to `_hasVoted`\ninvariant onlyLegalVotedChanges()\n    !illegalStore;",
        "type": "invariant",
        "id": "onlyLegalVotedChanges",
        "title": "No illegal changes to `_hasVoted`"
    },
    {
        "content": "/// @title Total votes is the number of times `_hasVoted` been written to\ninvariant sumVotedEqualssTotalVotes()\n     to_mathint(totalVotes()) == numVoted;",
        "type": "invariant",
        "id": "sumVotedEqualssTotalVotes",
        "title": "Total votes is the number of times `_hasVoted` been written to"
    },
    {
        "content": "/// @title Sum of voter in favor and against equals total number of voted\ninvariant sumResultsEqualsTotalVotes()\n    votesInFavor() + votesAgainst() == to_mathint(totalVotes());",
        "type": "invariant",
        "id": "sumResultsEqualsTotalVotes",
        "title": "Sum of voter in favor and against equals total number of voted"
    },
    {
        "content": "/// @title Only the method `vote` can be used to vote\nrule voteOnlyByCallingVote(method f) {\n    require !someoneVoted;\n\n    env e;\n    calldataarg args;\n    f(e, args);\n\n    assert (\n        someoneVoted => f.selector == sig:vote(bool).selector,\n        \"Voted only via vote\"\n    );\n}",
        "type": "rule",
        "id": "voteOnlyByCallingVote",
        "title": "Only the method `vote` can be used to vote",
        "params": [
            {
                "type": "method",
                "name": "f"
            }
        ]
    },
    {
        "content": "/// @title Votes in favor or against can only change by 1\nrule votesChangeByOne(method f) {\n    uint256 preFavor = votesInFavor();\n    uint256 preAgainst = votesAgainst();\n\n    env e;\n    calldataarg args;\n    f(e, args);\n\n    mathint favorDiff = votesInFavor() - preFavor;\n    mathint againstDiff = votesAgainst() - preAgainst;\n\n    assert favorDiff >= 0 && favorDiff <= 1, \"In favor may change by 0 or 1\";\n    assert againstDiff >= 0 && againstDiff <= 1, \"Against may change by 0 or 1\";\n}",
        "type": "rule",
        "id": "votesChangeByOne",
        "title": "Votes in favor or against can only change by 1",
        "params": [
            {
                "type": "method",
                "name": "f"
            }
        ]
    },
    {
        "content": "/// @title Voter determines if vote in favor or against\nrule voterDecides(bool isInFavor) {\n    uint256 preFavor = votesInFavor();\n    uint256 preAgainst = votesAgainst();\n\n    env e;\n    vote(e, isInFavor);\n\n    uint256 postFavor = votesInFavor();\n    uint256 postAgainst = votesAgainst();\n\n    assert (\n        (isInFavor => (postFavor > preFavor)) &&\n        (!isInFavor => (postAgainst > preAgainst))\n    ), \"Voter determines if vote is in favor or against\";\n}",
        "type": "rule",
        "id": "voterDecides",
        "title": "Voter determines if vote in favor or against",
        "params": [
            {
                "type": "bool",
                "name": "isInFavor"
            }
        ]
    },
    {
        "content": "/// @title Anyone can vote once\nrule anyoneCanVote(address voter, bool isInFavor) {\n    bool preHasVoted = hasVoted(voter);\n    uint256 preTotal = totalVotes();\n\n    env e;\n    require e.msg.sender == voter;\n\n    // Limit the overflow cases - this means we need only check `totalVotes`\n    requireInvariant sumResultsEqualsTotalVotes();\n\n    vote@withrevert(e, isInFavor);    \n\n    assert (\n        lastReverted <=> (\n            preHasVoted  // Revert since voted before\n            || e.msg.value > 0  // Sending ETH will cause revert\n            || preTotal == max_uint256  // Revert due to overflow\n        )\n    ), \"Can vote first time\";\n}",
        "type": "rule",
        "id": "anyoneCanVote",
        "title": "Anyone can vote once",
        "params": [
            {
                "type": "address",
                "name": "voter"
            },
            {
                "type": "bool",
                "name": "isInFavor"
            }
        ]
    }
]